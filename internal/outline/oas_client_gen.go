// Code generated by ogen, DO NOT EDIT.

package outline

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AccessKeysGet invokes GET /access-keys operation.
	//
	// Lists the access keys.
	//
	// GET /access-keys
	AccessKeysGet(ctx context.Context) (*AccessKeysGetOK, error)
	// AccessKeysIDDataLimitDelete invokes DELETE /access-keys/{id}/data-limit operation.
	//
	// Removes the data limit on the given access key.
	//
	// DELETE /access-keys/{id}/data-limit
	AccessKeysIDDataLimitDelete(ctx context.Context, params AccessKeysIDDataLimitDeleteParams) (AccessKeysIDDataLimitDeleteRes, error)
	// AccessKeysIDDataLimitPut invokes PUT /access-keys/{id}/data-limit operation.
	//
	// Sets a data limit for the given access key.
	//
	// PUT /access-keys/{id}/data-limit
	AccessKeysIDDataLimitPut(ctx context.Context, request *DataLimit, params AccessKeysIDDataLimitPutParams) (AccessKeysIDDataLimitPutRes, error)
	// AccessKeysIDDelete invokes DELETE /access-keys/{id} operation.
	//
	// Deletes an access key.
	//
	// DELETE /access-keys/{id}
	AccessKeysIDDelete(ctx context.Context, params AccessKeysIDDeleteParams) (AccessKeysIDDeleteRes, error)
	// AccessKeysIDGet invokes GET /access-keys/{id} operation.
	//
	// Get an access key.
	//
	// GET /access-keys/{id}
	AccessKeysIDGet(ctx context.Context, params AccessKeysIDGetParams) (AccessKeysIDGetRes, error)
	// AccessKeysIDNamePut invokes PUT /access-keys/{id}/name operation.
	//
	// Renames an access key.
	//
	// PUT /access-keys/{id}/name
	AccessKeysIDNamePut(ctx context.Context, request *AccessKeysIDNamePutReq, params AccessKeysIDNamePutParams) (AccessKeysIDNamePutRes, error)
	// AccessKeysIDPut invokes PUT /access-keys/{id} operation.
	//
	// Creates a new access key with a specific identifer.
	//
	// PUT /access-keys/{id}
	AccessKeysIDPut(ctx context.Context, request OptAccessKeysIDPutReq, params AccessKeysIDPutParams) (*AccessKey, error)
	// AccessKeysPost invokes POST /access-keys operation.
	//
	// Creates a new access key.
	//
	// POST /access-keys
	AccessKeysPost(ctx context.Context, request OptAccessKeysPostReq) (*AccessKey, error)
	// ExperimentalAccessKeyDataLimitDelete invokes DELETE /experimental/access-key-data-limit operation.
	//
	// (Deprecated) Removes the access key data limit, lifting data transfer restrictions on all access
	// keys.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// DELETE /experimental/access-key-data-limit
	ExperimentalAccessKeyDataLimitDelete(ctx context.Context) error
	// ExperimentalAccessKeyDataLimitPut invokes PUT /experimental/access-key-data-limit operation.
	//
	// (Deprecated) Sets a data transfer limit for all access keys.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// PUT /experimental/access-key-data-limit
	ExperimentalAccessKeyDataLimitPut(ctx context.Context, request *DataLimit) (ExperimentalAccessKeyDataLimitPutRes, error)
	// ExperimentalAsnMetricsEnabledPut invokes PUT /experimental/asn-metrics/enabled operation.
	//
	// Annotates Prometheus data metrics with autonomous system numbers (ASN).
	//
	// PUT /experimental/asn-metrics/enabled
	ExperimentalAsnMetricsEnabledPut(ctx context.Context, request *ExperimentalAsnMetricsEnabledPutReq) (ExperimentalAsnMetricsEnabledPutRes, error)
	// MetricsEnabledGet invokes GET /metrics/enabled operation.
	//
	// Returns whether metrics is being shared.
	//
	// GET /metrics/enabled
	MetricsEnabledGet(ctx context.Context) (*MetricsEnabledGetOK, error)
	// MetricsEnabledPut invokes PUT /metrics/enabled operation.
	//
	// Enables or disables sharing of metrics.
	//
	// PUT /metrics/enabled
	MetricsEnabledPut(ctx context.Context, request *MetricsEnabledPutReq) (MetricsEnabledPutRes, error)
	// MetricsTransferGet invokes GET /metrics/transfer operation.
	//
	// Returns the data transferred per access key.
	//
	// GET /metrics/transfer
	MetricsTransferGet(ctx context.Context) (*MetricsTransferGetOK, error)
	// NamePut invokes PUT /name operation.
	//
	// Renames the server.
	//
	// PUT /name
	NamePut(ctx context.Context, request *NamePutReq) (NamePutRes, error)
	// ServerAccessKeyDataLimitDelete invokes DELETE /server/access-key-data-limit operation.
	//
	// Removes the access key data limit, lifting data transfer restrictions on all access keys.
	//
	// DELETE /server/access-key-data-limit
	ServerAccessKeyDataLimitDelete(ctx context.Context) error
	// ServerAccessKeyDataLimitPut invokes PUT /server/access-key-data-limit operation.
	//
	// Sets a data transfer limit for all access keys.
	//
	// PUT /server/access-key-data-limit
	ServerAccessKeyDataLimitPut(ctx context.Context, request *DataLimit) (ServerAccessKeyDataLimitPutRes, error)
	// ServerGet invokes GET /server operation.
	//
	// Returns information about the server.
	//
	// GET /server
	ServerGet(ctx context.Context) (*Server, error)
	// ServerHostnameForAccessKeysPut invokes PUT /server/hostname-for-access-keys operation.
	//
	// Changes the hostname for access keys.  Must be a valid hostname or IP address.  If it's a hostname,
	//  DNS must be set up independently of this API.
	//
	// PUT /server/hostname-for-access-keys
	ServerHostnameForAccessKeysPut(ctx context.Context, request *ServerHostnameForAccessKeysPutReq) (ServerHostnameForAccessKeysPutRes, error)
	// ServerPortForNewAccessKeysPut invokes PUT /server/port-for-new-access-keys operation.
	//
	// Changes the default port for newly created access keys.  This can be a port already used for
	// access keys.
	//
	// PUT /server/port-for-new-access-keys
	ServerPortForNewAccessKeysPut(ctx context.Context, request *ServerPortForNewAccessKeysPutReq) (ServerPortForNewAccessKeysPutRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AccessKeysGet invokes GET /access-keys operation.
//
// Lists the access keys.
//
// GET /access-keys
func (c *Client) AccessKeysGet(ctx context.Context) (*AccessKeysGetOK, error) {
	res, err := c.sendAccessKeysGet(ctx)
	return res, err
}

func (c *Client) sendAccessKeysGet(ctx context.Context) (res *AccessKeysGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/access-keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/access-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysIDDataLimitDelete invokes DELETE /access-keys/{id}/data-limit operation.
//
// Removes the data limit on the given access key.
//
// DELETE /access-keys/{id}/data-limit
func (c *Client) AccessKeysIDDataLimitDelete(ctx context.Context, params AccessKeysIDDataLimitDeleteParams) (AccessKeysIDDataLimitDeleteRes, error) {
	res, err := c.sendAccessKeysIDDataLimitDelete(ctx, params)
	return res, err
}

func (c *Client) sendAccessKeysIDDataLimitDelete(ctx context.Context, params AccessKeysIDDataLimitDeleteParams) (res AccessKeysIDDataLimitDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/access-keys/{id}/data-limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysIDDataLimitDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/access-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/data-limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysIDDataLimitDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysIDDataLimitPut invokes PUT /access-keys/{id}/data-limit operation.
//
// Sets a data limit for the given access key.
//
// PUT /access-keys/{id}/data-limit
func (c *Client) AccessKeysIDDataLimitPut(ctx context.Context, request *DataLimit, params AccessKeysIDDataLimitPutParams) (AccessKeysIDDataLimitPutRes, error) {
	res, err := c.sendAccessKeysIDDataLimitPut(ctx, request, params)
	return res, err
}

func (c *Client) sendAccessKeysIDDataLimitPut(ctx context.Context, request *DataLimit, params AccessKeysIDDataLimitPutParams) (res AccessKeysIDDataLimitPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/access-keys/{id}/data-limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysIDDataLimitPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/access-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/data-limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccessKeysIDDataLimitPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysIDDataLimitPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysIDDelete invokes DELETE /access-keys/{id} operation.
//
// Deletes an access key.
//
// DELETE /access-keys/{id}
func (c *Client) AccessKeysIDDelete(ctx context.Context, params AccessKeysIDDeleteParams) (AccessKeysIDDeleteRes, error) {
	res, err := c.sendAccessKeysIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendAccessKeysIDDelete(ctx context.Context, params AccessKeysIDDeleteParams) (res AccessKeysIDDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/access-keys/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysIDDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/access-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysIDGet invokes GET /access-keys/{id} operation.
//
// Get an access key.
//
// GET /access-keys/{id}
func (c *Client) AccessKeysIDGet(ctx context.Context, params AccessKeysIDGetParams) (AccessKeysIDGetRes, error) {
	res, err := c.sendAccessKeysIDGet(ctx, params)
	return res, err
}

func (c *Client) sendAccessKeysIDGet(ctx context.Context, params AccessKeysIDGetParams) (res AccessKeysIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/access-keys/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysIDGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/access-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysIDNamePut invokes PUT /access-keys/{id}/name operation.
//
// Renames an access key.
//
// PUT /access-keys/{id}/name
func (c *Client) AccessKeysIDNamePut(ctx context.Context, request *AccessKeysIDNamePutReq, params AccessKeysIDNamePutParams) (AccessKeysIDNamePutRes, error) {
	res, err := c.sendAccessKeysIDNamePut(ctx, request, params)
	return res, err
}

func (c *Client) sendAccessKeysIDNamePut(ctx context.Context, request *AccessKeysIDNamePutReq, params AccessKeysIDNamePutParams) (res AccessKeysIDNamePutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/access-keys/{id}/name"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysIDNamePut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/access-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/name"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccessKeysIDNamePutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysIDNamePutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysIDPut invokes PUT /access-keys/{id} operation.
//
// Creates a new access key with a specific identifer.
//
// PUT /access-keys/{id}
func (c *Client) AccessKeysIDPut(ctx context.Context, request OptAccessKeysIDPutReq, params AccessKeysIDPutParams) (*AccessKey, error) {
	res, err := c.sendAccessKeysIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendAccessKeysIDPut(ctx context.Context, request OptAccessKeysIDPutReq, params AccessKeysIDPutParams) (res *AccessKey, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/access-keys/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysIDPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/access-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccessKeysIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccessKeysPost invokes POST /access-keys operation.
//
// Creates a new access key.
//
// POST /access-keys
func (c *Client) AccessKeysPost(ctx context.Context, request OptAccessKeysPostReq) (*AccessKey, error) {
	res, err := c.sendAccessKeysPost(ctx, request)
	return res, err
}

func (c *Client) sendAccessKeysPost(ctx context.Context, request OptAccessKeysPostReq) (res *AccessKey, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/access-keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AccessKeysPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/access-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAccessKeysPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccessKeysPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExperimentalAccessKeyDataLimitDelete invokes DELETE /experimental/access-key-data-limit operation.
//
// (Deprecated) Removes the access key data limit, lifting data transfer restrictions on all access
// keys.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /experimental/access-key-data-limit
func (c *Client) ExperimentalAccessKeyDataLimitDelete(ctx context.Context) error {
	_, err := c.sendExperimentalAccessKeyDataLimitDelete(ctx)
	return err
}

func (c *Client) sendExperimentalAccessKeyDataLimitDelete(ctx context.Context) (res *ExperimentalAccessKeyDataLimitDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/experimental/access-key-data-limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ExperimentalAccessKeyDataLimitDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/experimental/access-key-data-limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExperimentalAccessKeyDataLimitDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExperimentalAccessKeyDataLimitPut invokes PUT /experimental/access-key-data-limit operation.
//
// (Deprecated) Sets a data transfer limit for all access keys.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /experimental/access-key-data-limit
func (c *Client) ExperimentalAccessKeyDataLimitPut(ctx context.Context, request *DataLimit) (ExperimentalAccessKeyDataLimitPutRes, error) {
	res, err := c.sendExperimentalAccessKeyDataLimitPut(ctx, request)
	return res, err
}

func (c *Client) sendExperimentalAccessKeyDataLimitPut(ctx context.Context, request *DataLimit) (res ExperimentalAccessKeyDataLimitPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/experimental/access-key-data-limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ExperimentalAccessKeyDataLimitPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/experimental/access-key-data-limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExperimentalAccessKeyDataLimitPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExperimentalAccessKeyDataLimitPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExperimentalAsnMetricsEnabledPut invokes PUT /experimental/asn-metrics/enabled operation.
//
// Annotates Prometheus data metrics with autonomous system numbers (ASN).
//
// PUT /experimental/asn-metrics/enabled
func (c *Client) ExperimentalAsnMetricsEnabledPut(ctx context.Context, request *ExperimentalAsnMetricsEnabledPutReq) (ExperimentalAsnMetricsEnabledPutRes, error) {
	res, err := c.sendExperimentalAsnMetricsEnabledPut(ctx, request)
	return res, err
}

func (c *Client) sendExperimentalAsnMetricsEnabledPut(ctx context.Context, request *ExperimentalAsnMetricsEnabledPutReq) (res ExperimentalAsnMetricsEnabledPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/experimental/asn-metrics/enabled"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ExperimentalAsnMetricsEnabledPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/experimental/asn-metrics/enabled"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExperimentalAsnMetricsEnabledPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExperimentalAsnMetricsEnabledPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetricsEnabledGet invokes GET /metrics/enabled operation.
//
// Returns whether metrics is being shared.
//
// GET /metrics/enabled
func (c *Client) MetricsEnabledGet(ctx context.Context) (*MetricsEnabledGetOK, error) {
	res, err := c.sendMetricsEnabledGet(ctx)
	return res, err
}

func (c *Client) sendMetricsEnabledGet(ctx context.Context) (res *MetricsEnabledGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/metrics/enabled"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetricsEnabledGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics/enabled"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetricsEnabledGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetricsEnabledPut invokes PUT /metrics/enabled operation.
//
// Enables or disables sharing of metrics.
//
// PUT /metrics/enabled
func (c *Client) MetricsEnabledPut(ctx context.Context, request *MetricsEnabledPutReq) (MetricsEnabledPutRes, error) {
	res, err := c.sendMetricsEnabledPut(ctx, request)
	return res, err
}

func (c *Client) sendMetricsEnabledPut(ctx context.Context, request *MetricsEnabledPutReq) (res MetricsEnabledPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/metrics/enabled"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetricsEnabledPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics/enabled"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMetricsEnabledPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetricsEnabledPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetricsTransferGet invokes GET /metrics/transfer operation.
//
// Returns the data transferred per access key.
//
// GET /metrics/transfer
func (c *Client) MetricsTransferGet(ctx context.Context) (*MetricsTransferGetOK, error) {
	res, err := c.sendMetricsTransferGet(ctx)
	return res, err
}

func (c *Client) sendMetricsTransferGet(ctx context.Context) (res *MetricsTransferGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/metrics/transfer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MetricsTransferGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetricsTransferGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NamePut invokes PUT /name operation.
//
// Renames the server.
//
// PUT /name
func (c *Client) NamePut(ctx context.Context, request *NamePutReq) (NamePutRes, error) {
	res, err := c.sendNamePut(ctx, request)
	return res, err
}

func (c *Client) sendNamePut(ctx context.Context, request *NamePutReq) (res NamePutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/name"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "NamePut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/name"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNamePutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeNamePutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServerAccessKeyDataLimitDelete invokes DELETE /server/access-key-data-limit operation.
//
// Removes the access key data limit, lifting data transfer restrictions on all access keys.
//
// DELETE /server/access-key-data-limit
func (c *Client) ServerAccessKeyDataLimitDelete(ctx context.Context) error {
	_, err := c.sendServerAccessKeyDataLimitDelete(ctx)
	return err
}

func (c *Client) sendServerAccessKeyDataLimitDelete(ctx context.Context) (res *ServerAccessKeyDataLimitDeleteNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/server/access-key-data-limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ServerAccessKeyDataLimitDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/server/access-key-data-limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeServerAccessKeyDataLimitDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServerAccessKeyDataLimitPut invokes PUT /server/access-key-data-limit operation.
//
// Sets a data transfer limit for all access keys.
//
// PUT /server/access-key-data-limit
func (c *Client) ServerAccessKeyDataLimitPut(ctx context.Context, request *DataLimit) (ServerAccessKeyDataLimitPutRes, error) {
	res, err := c.sendServerAccessKeyDataLimitPut(ctx, request)
	return res, err
}

func (c *Client) sendServerAccessKeyDataLimitPut(ctx context.Context, request *DataLimit) (res ServerAccessKeyDataLimitPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/server/access-key-data-limit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ServerAccessKeyDataLimitPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/server/access-key-data-limit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServerAccessKeyDataLimitPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeServerAccessKeyDataLimitPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServerGet invokes GET /server operation.
//
// Returns information about the server.
//
// GET /server
func (c *Client) ServerGet(ctx context.Context) (*Server, error) {
	res, err := c.sendServerGet(ctx)
	return res, err
}

func (c *Client) sendServerGet(ctx context.Context) (res *Server, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/server"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ServerGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/server"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeServerGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServerHostnameForAccessKeysPut invokes PUT /server/hostname-for-access-keys operation.
//
// Changes the hostname for access keys.  Must be a valid hostname or IP address.  If it's a hostname,
//
//	DNS must be set up independently of this API.
//
// PUT /server/hostname-for-access-keys
func (c *Client) ServerHostnameForAccessKeysPut(ctx context.Context, request *ServerHostnameForAccessKeysPutReq) (ServerHostnameForAccessKeysPutRes, error) {
	res, err := c.sendServerHostnameForAccessKeysPut(ctx, request)
	return res, err
}

func (c *Client) sendServerHostnameForAccessKeysPut(ctx context.Context, request *ServerHostnameForAccessKeysPutReq) (res ServerHostnameForAccessKeysPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/server/hostname-for-access-keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ServerHostnameForAccessKeysPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/server/hostname-for-access-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServerHostnameForAccessKeysPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeServerHostnameForAccessKeysPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServerPortForNewAccessKeysPut invokes PUT /server/port-for-new-access-keys operation.
//
// Changes the default port for newly created access keys.  This can be a port already used for
// access keys.
//
// PUT /server/port-for-new-access-keys
func (c *Client) ServerPortForNewAccessKeysPut(ctx context.Context, request *ServerPortForNewAccessKeysPutReq) (ServerPortForNewAccessKeysPutRes, error) {
	res, err := c.sendServerPortForNewAccessKeysPut(ctx, request)
	return res, err
}

func (c *Client) sendServerPortForNewAccessKeysPut(ctx context.Context, request *ServerPortForNewAccessKeysPutReq) (res ServerPortForNewAccessKeysPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/server/port-for-new-access-keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ServerPortForNewAccessKeysPut",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/server/port-for-new-access-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServerPortForNewAccessKeysPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeServerPortForNewAccessKeysPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

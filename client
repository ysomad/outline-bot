package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"
)

// https://github.com/Jigsaw-Code/outline-server/blob/master/src/shadowbox/README.md
type Client struct {
	*http.Client
	apiURL string
}

func NewClient(c *http.Client, apiURL string) Client {
	return Client{
		Client: c,
		apiURL: apiURL,
	}
}

const accessKeyPath = "access-keys"

type AccessKey struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Password  string `json:"password"`
	Method    string `json:"method"`
	Port      int32  `json:"port"`
	AccessURL string `json:"accessUrl"`
}

func (c Client) AccessKey(id string) (AccessKey, error) {
	url, err := url.JoinPath(c.apiURL, accessKeyPath, id)
	if err != nil {
		return AccessKey{}, fmt.Errorf("request url not joined: %w", err)
	}

	slog.Info(url)

	res, err := c.Get(url)
	if err != nil {
		return AccessKey{}, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return AccessKey{}, fmt.Errorf("couldnt get access key, status: %d", res.StatusCode)
	}

	var key AccessKey

	if err := json.NewDecoder(res.Body).Decode(&key); err != nil {
		return AccessKey{}, fmt.Errorf("body not decoded: %w", err)
	}

	return key, nil
}

func (c Client) AccessKeys() ([]AccessKey, error) {
	url, err := url.JoinPath(c.apiURL, accessKeyPath)
	if err != nil {
		return nil, fmt.Errorf("request url not joined: %w", err)
	}

	slog.Info(url)

	res, err := c.Get(url)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("couldnt get access keys, status: %d", res.StatusCode)
	}

	type body struct {
		AccessKeys []AccessKey `json:"accessKeys"`
	}

	var b body

	if err := json.NewDecoder(res.Body).Decode(&b); err != nil {
		return nil, fmt.Errorf("body not decoded: %w", err)
	}

	return b.AccessKeys, nil
}

func (c Client) CreateAccessKey(name string) (AccessKey, error) {
	type body struct {
		Name string `json:"name"`
	}

	bb, err := json.Marshal(body{Name: name})
	if err != nil {
		return AccessKey{}, fmt.Errorf("body not marshaled: %w", err)
	}

	url, err := url.JoinPath(c.apiURL, accessKeyPath)
	if err != nil {
		return AccessKey{}, fmt.Errorf("request url not joined: %w", err)
	}

	slog.Info(url)

	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(bb))
	if err != nil {
		return AccessKey{}, fmt.Errorf("request not created: %w", err)
	}

	res, err := c.Do(req)
	if err != nil {
		return AccessKey{}, fmt.Errorf("client failed: %w", err)
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusCreated {
		return AccessKey{}, fmt.Errorf("acccess key not created, status: %d", res.StatusCode)
	}

	var key AccessKey

	if err := json.NewDecoder(req.Body).Decode(&key); err != nil {
		return AccessKey{}, fmt.Errorf("body not decoded: %w", err)
	}

	return key, nil
}

func (c Client) RemoveAccessKey() error {
	url, err := url.JoinPath(c.apiURL, accessKeyPath)
	if err != nil {
		return fmt.Errorf("request url not joined: %w", err)
	}

	req, err := http.NewRequest(http.MethodDelete, url, nil)
	if err != nil {
		return fmt.Errorf("request not created: %w", err)
	}

	res, err := c.Do(req)
	if err != nil {
		return fmt.Errorf("client failed: %w", err)
	}

	if res.StatusCode != http.StatusNoContent {
		return fmt.Errorf("access key not removed: %w", err)
	}

	return nil
}
